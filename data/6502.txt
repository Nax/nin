SelectSourceA   _selSrc = REG_A;
SelectSourceX   _selSrc = REG_X;
SelectSourceY   _selSrc = REG_Y;

SelectDestA     _selDst = REG_A;
SelectDestX     _selDst = REG_X;
SelectDestY     _selDst = REG_Y;

AddrSet_NMI     _addr = 0xfffa;
AddrSet_RESET   _addr = 0xfffc;
AddrSet_BRK     _addr = 0xfffe;

DecS            _s--;
IncS            _s++;
IncPC           _pc++;

AddrImpl            read(_pc);
AddrImplIncPC       read(_pc++);
AddrZero            _addr = read(_pc++);
AddrZeroX           _addr = (_addr + _x) & 0xff;
AddrZeroY           _addr = (_addr + _y) & 0xff;
AddrAbsLo           _addr = ((_addr & 0xff00) | read(_pc++));
AddrAbsHi           _addr = ((_addr & 0x00ff) | ((std::uint16_t)read(_pc++)) << 8);
AddrAbsHiX          _addrCarry = (((_addr & 0xff) + _x) > 0xff) ? 1 : 0; _addr = (((_addr + _x) & 0x00ff) | ((std::uint16_t)read(_pc++)) << 8);
AddrAbsHiY          _addrCarry = (((_addr & 0xff) + _y) > 0xff) ? 1 : 0; _addr = (((_addr + _y) & 0x00ff) | ((std::uint16_t)read(_pc++)) << 8);
AddrCarry           read(_addr); _addr += (((std::uint16_t)_addrCarry) << 8);
AddrCarryIf         if (!_addrCarry) {
AddrCarryEnd        return (Handler)&CPU::dispatch; }
AddrCarryFix        _addr += 0x100;
AddrIndirectLo      _addr = _addr | ((std::uint16_t)_memory.ram[_addr] << 8);
AddrIndirectHi      _addr = (_addr >> 8) | ((std::uint16_t)_memory.ram[(_addr + 1) & 0xff] << 8);
AddrIndirectY       _addrCarry = (((_addr & 0xff) + _y) > 0xff) ? 1 : 0; _addr = (_addr & 0xff00) | ((_addr + _y) & 0xff);

DummyLoad           read(_addr);

TmpLoad             std::uint8_t tmp = read(_addr);
TmpLoadImm          std::uint8_t tmp = read(_pc++);
TmpLoadZero         std::uint8_t tmp = _memory.ram[_addr];
TmpLoadAcc          std::uint8_t tmp = _a;
TmpLoadRmw          std::uint8_t tmp = _rmw;
TmpStoreAcc         _a = tmp;
TmpStoreRmw         _rmw = tmp;

RmwLoad             _rmw = read(_addr);
RmwLoadZero         _rmw = _memory.ram[_addr];
RmwStore            next = write(_addr, _rmw, next);
RmwStoreZero        _memory.ram[_addr] = _rmw;

BranchClearC    if (_p & PFLAG_C) { return (Handler)&CPU::dispatch; }
BranchClearN    if (_p & PFLAG_N) { return (Handler)&CPU::dispatch; }
BranchClearV    if (_p & PFLAG_V) { return (Handler)&CPU::dispatch; }
BranchClearZ    if (_p & PFLAG_Z) { return (Handler)&CPU::dispatch; }
BranchSetC      if (!(_p & PFLAG_C)) { return (Handler)&CPU::dispatch; }
BranchSetN      if (!(_p & PFLAG_N)) { return (Handler)&CPU::dispatch; }
BranchSetV      if (!(_p & PFLAG_V)) { return (Handler)&CPU::dispatch; }
BranchSetZ      if (!(_p & PFLAG_Z)) { return (Handler)&CPU::dispatch; }

BranchTake      _addrCarry = (((_pc + (std::int8_t)_addr) ^ _pc) & 0xff00) ? 1 : 0; _addr = _pc + (std::int8_t)_addr; _pc = ((_pc & 0xff00) | (_addr & 0xff));
BranchTake2     if (!_addrCarry) return (Handler)&CPU::dispatch; _pc = _addr;

PushPCL         _memory.ram[0x100 | _s] = (_pc & 0xff);
PushPCH         _memory.ram[0x100 | _s] = (_pc >> 8);
PushP           _memory.ram[0x100 | _s] = _p | PFLAG_1 | PFLAG_B;
PushP_NoB       _memory.ram[0x100 | _s] = _p | PFLAG_1;
PushA           _memory.ram[0x100 | _s] = _a;
PullPCL         _pc = (_pc & 0xff00) | _memory.ram[0x100 | _s];
PullPCH         _pc = (_pc & 0x00ff) | ((std::uint16_t)_memory.ram[0x100 | _s] << 8);
PullP           _p = _memory.ram[0x100 | _s] & ~(PFLAG_1 | PFLAG_B);
PullA           _a = _memory.ram[0x100 | _s]; flagNZ(_a);

VectorPCL           _pc = ((_pc & 0xff00) | read(_addr));
VectorPCH           _pc = ((_pc & 0x00ff) | (((std::uint16_t)read(_addr + 1)) << 8));
VectorPCH_NoCarry   _pc = ((_pc & 0x00ff) | ((std::uint16_t)read((_addr & 0xff00) | ((_addr + 1) & 0xff))) << 8);

ImmLoadA        _a = read(_pc++); flagNZ(_a);
ImmLoadX        _x = read(_pc++); flagNZ(_x);
ImmLoadY        _y = read(_pc++); flagNZ(_y);

OpORA        _regs[_selDst] |= tmp; flagNZ(_regs[_selDst]);
OpAND        _regs[_selDst] &= tmp; flagNZ(_regs[_selDst]);
OpEOR        _regs[_selDst] ^= tmp; flagNZ(_regs[_selDst]);
OpCMP        _p &= ~PFLAG_C; _p |= (_regs[_selDst] >= tmp) ? PFLAG_C : 0; flagNZ(_regs[_selDst] - tmp);
OpBIT        _p &= ~(PFLAG_Z | PFLAG_N | PFLAG_V); _p |= (tmp & 0xc0); _p |= ((_a & tmp) ? 0 : PFLAG_Z);
OpADC       _a = adc(_a, tmp);
OpSBC       _a = adc(_a, ~tmp);

OpINC       flagNZ(++tmp);
OpDEC       flagNZ(--tmp);
OpASL       _p &= ~PFLAG_C; _p |= ((tmp & 0x80) ? PFLAG_C : 0); tmp <<= 1; flagNZ(tmp);
OpLSR       _p &= ~(PFLAG_N | PFLAG_Z | PFLAG_C); _p |= ((tmp & 0x01) ? PFLAG_C : 0); tmp >>= 1; _p |= (tmp ? 0 : PFLAG_Z);
OpROL       std::uint8_t c = (_p & PFLAG_C ? 0x01 : 0x00); _p &= ~PFLAG_C; _p |= ((tmp & 0x80) ? PFLAG_C : 0); tmp = ((tmp << 1) | c); flagNZ(tmp);
OpROR       std::uint8_t c = (_p & PFLAG_C ? 0x80 : 0x00); _p &= ~PFLAG_C; _p |= ((tmp & 0x01) ? PFLAG_C : 0); tmp = ((tmp >> 1) | c); flagNZ(tmp);

OpSLO       _p &= ~PFLAG_C; _p |= ((tmp & 0x80) ? PFLAG_C : 0); tmp <<= 1; _a |= tmp; flagNZ(_a);
OpRLA       std::uint8_t c = (_p & PFLAG_C ? 0x01 : 0x00); _p &= ~PFLAG_C; _p |= ((tmp & 0x80) ? PFLAG_C : 0); tmp = ((tmp << 1) | c); _a &= tmp; flagNZ(_a);
OpSRE       _p &= ~PFLAG_C; _p |= ((tmp & 0x01) ? PFLAG_C : 0); tmp >>= 1; _a ^= tmp; flagNZ(_a);
OpRRA       std::uint8_t c = (_p & PFLAG_C ? 0x80 : 0x00); _p &= ~PFLAG_C; _p |= ((tmp & 0x01) ? PFLAG_C : 0); tmp = ((tmp >> 1) | c); _a = adc(_a, tmp);

OpANC       _p &= ~PFLAG_C; _regs[_selDst] &= tmp; flagNZ(_regs[_selDst]); _p |= (_p & PFLAG_N) ? PFLAG_C : 0;

INX      flagNZ(++_x);
INY      flagNZ(++_y);
DEX      flagNZ(--_x);
DEY      flagNZ(--_y);

FlagClearC      _p &= ~PFLAG_C;
FlagClearI      _p &= ~PFLAG_I;
FlagClearV      _p &= ~PFLAG_V;
FlagClearD      _p &= ~PFLAG_D;

FlagSetC        _p |= PFLAG_C;
FlagSetI        _p |= PFLAG_I;
FlagSetD        _p |= PFLAG_D;

WriteReg        next = write(_addr, _regs[_selSrc], next);
WriteRegZero    _memory.ram[_addr] = _regs[_selSrc];

ReadReg         _regs[_selDst] = read(_addr); flagNZ(_regs[_selDst]);
ReadRegCarry    _regs[_selDst] = read(_addr); flagNZ(_regs[_selDst]); _addr += ((std::uint16_t)_addrCarry << 8); if (!_addrCarry) return ((Handler)&CPU::dispatch);
ReadRegZero     _regs[_selDst] = _memory.ram[_addr]; flagNZ(_regs[_selDst]);

CarryFix        _addr += ((std::uint16_t)_addrCarry << 8);

TransferAX      _x = _a; flagNZ(_a);
TransferAY      _y = _a; flagNZ(_a);
TransferSX      _x = _s; flagNZ(_s);
TransferXA      _a = _x; flagNZ(_x);
TransferXS      _s = _x;
TransferYA      _a = _y; flagNZ(_y);

Nop             /* nop */;
ReadAddr        read(_addr);

SwitchPC            _pc = (_addr | ((std::uint16_t)read(_pc) << 8));
